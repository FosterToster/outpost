# outpost
Powerful python data validation module

Предоставляет функуионал валидация и маппинга входящих данных по описанным моделям.

## Почему не pydantic
- pydantic не обеспечивает достаточного функционала (см ниже)

----
## Функционал
- Автоматическое приведение к типам с поддержкой модуля typing
- Сложные логические правила для обязательных полей
- Сложные правила валидации
- Валидация вложенных моделей
- Описание readonly полей
- Указание значений по-умолчанию
- !Валиация комбинаций полей (WIP)
- Наследование правил с возможностью модификации
- Несколько режимов валидации:
  - Упрощенный: простой маппинг модели по входящему набору данных
  - Расширенный: ручное выполнение с помощью chain-методов c базовой локальной модификацией правил валидации
  - Сложный: Контекстная валидация с возможностью полной локальной модификации правил валидации

## Поддержка моделей данных
- dataclasses
- модели sqlalchemy.DeclarativeMeta 

## Использование
### Базовые и ситуативные валидаторы
Базовый валидатор - это статический класс, унаследованный от Oupost, с определенными в нем правилами валидации\
(поле для хранения правил валидации может называться как угодно)
```python
# Создание нового валидатора
class SomeValidator(Outpost):
    # создание правил валидации на основе ранее описанной модели данных
    custom_configuration_name = OutpostProvider.from_model(Some)
```
Базовый валидатор выполняет только проверку типов данных в соответствии с указанными в модели

Ситуативный валидатор - это статический класс, унаследованный от базового валидатора,\
в котором правила валидации унаследованы явно, а так же указаны более строгие правила валидации данных (если необходимо)
```python
# Создание валидатора для кейса "создание" модели Some
class SomeCreateValidator(SomeValidator):
    # явное наследование правил валидации для возможности модификации
    op = SomeValidator.custom_configuration_name
    # указание обязательного поля
    op.requiremets = op.fields.name
    
    # ПРИМЕР НЕПРАВИЛЬНОГО ИСПОЛЬЗОВАНИЯ
    # В рамках иерархии валидаторов уже существуют базовые правила валидации.
    # Не создавайте новые, используйте старые и расширяйте их
    op = OutpostProvider.from_model(Some)

```


Рекомендуется создавать базовый валидатор для каждой валидируемой модели, и на его основе создавать ситуативные.\
Однако в базовом валидаторе технически могут быть описаны сколь угодно сложные правила валидации.\
Поступайте так, если валидация данных необходима в одном единственном случае использования модели.

## Функционал описания правил валидации (OutpostProvider)
Для описания правил валидации используется Generic класс OutpostProvider, который инифиализируется с помощью специального статического метода: `.from_model(model:Union[dataclass, DeclarativeBase])`\
### Провайдер полей модели
Созданный на основе модели OutpostProvider содержит провайдер полей модели - `fields`, содержащий Enum, описывающий все пригодные для валидации поля описанной модели\
(Для датаклассов это поля, содержащие аннотацию типа, для sqlalchemy это колонки и relationship`s)

```python
# модель данных
@dataclass
class Some:
    name: str
    value: Optional(int)
    
# параметры валидации на основе модели данных
op = OutpostProvider.from_model(Some)

# обращения к полям модели данных
op.fields.name
op.fields.value
```
Дальнейшее описание всех правил валидации основано на использовании провайдера полей модели


# WIP
