# outpost
Powerful python data validation module

Предоставляет функуионал валидация и маппинга входящих данных по описанным моделям.

## Почему не pydantic
- pydantic не обеспечивает достаточного функционала (см ниже)

----
## Функционал
- Автоматическое приведение к типам с поддержкой модуля typing
- Сложные логические правила для обязательных полей
- Сложные правила валидации
- Валидация вложенных моделей
- Описание readonly полей
- Указание значений по-умолчанию
- !Валиация комбинаций полей (WIP)
- Наследование правил с возможностью модификации
- Несколько режимов валидации:
  - Упрощенный: простой маппинг модели по входящему набору данных
  - Расширенный: ручное выполнение с помощью chain-методов c базовой локальной модификацией правил валидации
  - Продвинутый: Контекстная валидация с возможностью полной локальной модификации правил валидации

## Поддержка моделей данных
- dataclasses
- модели sqlalchemy.DeclarativeMeta 

## Использование
### Базовые и ситуативные валидаторы
Базовый валидатор - это статический класс, унаследованный от Oupost, с определенными в нем правилами валидации\
(поле для хранения правил валидации может называться как угодно)
```python
# Создание нового валидатора
class SomeValidator(Outpost):
    # создание правил валидации на основе ранее описанной модели данных
    custom_configuration_name = OutpostProvider.from_model(Some)
```
Базовый валидатор выполняет только проверку типов данных в соответствии с указанными в модели

Ситуативный валидатор - это статический класс, унаследованный от базового валидатора,\
в котором правила валидации унаследованы явно, а так же указаны более строгие правила валидации данных (если необходимо)
```python
# Создание валидатора для кейса "создание" модели Some
class SomeCreateValidator(SomeValidator):
    # явное наследование правил валидации для возможности модификации
    op = SomeValidator.custom_configuration_name
    # указание обязательного поля
    op.requiremets = op.fields.name
    
    # ПРИМЕР НЕПРАВИЛЬНОГО ИСПОЛЬЗОВАНИЯ
    # В рамках иерархии валидаторов уже существуют базовые правила валидации.
    # Не создавайте новые, используйте старые и расширяйте их
    op = OutpostProvider.from_model(Some)

```


Рекомендуется создавать базовый валидатор для каждой валидируемой модели, и на его основе создавать ситуативные.\
Однако в базовом валидаторе технически могут быть описаны сколь угодно сложные правила валидации.\
Поступайте так, если валидация данных необходима в одном единственном случае использования модели.

## Функционал описания правил валидации (OutpostProvider)
Для описания правил валидации используется Generic класс OutpostProvider, который инифиализируется с помощью специального статического метода: `.from_model(model:Union[dataclass, DeclarativeBase])`\
### Провайдер полей модели
Созданный на основе модели OutpostProvider содержит провайдер полей модели - `fields`, содержащий перечисляемый тип ModelField, описывающий все пригодные для валидации поля описанной модели\
(Для датаклассов это поля, содержащие аннотацию типа, для sqlalchemy это колонки и relationship's)

```python
# модель данных
@dataclass
class Some:
    name: str
    value: Optional(int)
    
# параметры валидации на основе модели данных
op = OutpostProvider.from_model(Some)

# обращения к полям модели данных
op.fields.name
op.fields.value
```
Дальнейшее описание всех правил валидации основано на использовании провайдера полей модели

### Функционал определения обязательных полей (requirements)
Параметры валидации позволяют указать сложные логические правила для обязательных полей модели данных.\
Для этого экземпляр OutpostProvider предоставляет метод `.require`, или свойство `requirements`\
В метод или свойство могут быть записаны отдельные ModelField, или их логические комбинации.\
Используйте синтаксис логических и/или для определения.\
Множественный вызов метода `.require` объединит все переданные поля логическим И.\
Аналогично условием И объединяются правила в случае наследования валидаторов.

```python
# Определение обязательность полей   name AND value
op.require(op.fields.name & op.fields.value)

# Эквивалентная запись
op.require(op.fields.name)
op.require(op.fields.value)

# Эквивалентная запись, но для определения условия ИЛИ
op.requirements = op.fields.name | op.fields.value
```
Так-же возможно использование описательных классов из oupost.rules.[Require, OR, AND, NOT]

### Функционал определения readonly полей
Список readonly полей может быть указан в свойстве `.readonly` параметров валидации

```python
# Определение readonly поля value
op.readonly = [op.fields.value]
```
По-умолчанию readonly поля, переданные во входящем наборе данных будут отфильтрованы.\
Однако если установить `op.raise_readonly = True`, то при получении значения для readonly поля будет поднято исключение.\
Так-же существует схожий параметр: `op.raise_unnecessary`, при установке которого в True будет поднято исключение в случае передачи\
во входящем наборе данных полей, не определенных в модели.

### Функционал определения значений по-умолчанию
Значения по-умолчанию для полей модели могут быть записаны в свойство `op.defaults`
```python
# Определение значений по-умолчанию для полей name и value
op.defaults = {
  op.fields.name: "John",
  op.fields.values: 0
}
```
**Внимание! Значения по-умолчанию подлежат валидации типов.**
Так-же есть возможность определить специальное значение для всех полей, которые не были переданы во входящем наборе данных для случая,\
когда создание модели невозможно без указания значений всем ее полям (например dataclass)\
В примере ниже показано как задать значение None для всех остутствующих полей\
`op.missing_value = None`

### Функционал определения сложных правил валидации для поля
#### Для простых полей
Используйте метод `.validator` как декоратор, в аргумент которого передайте ModelField соответствующего поля.\
Декорируемая функция должна поднять ValidationError в случае ошибки, или вернуть провалидированное и нормальзованное значение.
```python
@op.validator(op.fields.name)
def name_validator(value):
  if len(name) < 3:
    raise ValidationError("Name is too short")
  return value
```
По-умолчанию значения, полученные в результате сложной валидации дополнительно проходят проверку типа, однако ее можно отключить:
```python
# отключение проверки типа для результата
@op.validator(op.fields.name, check_result_type=False)
def name_validator(value):
  if len(name) < 3:
    raise ValidationError("Name is too short")
  return SomeOther(value)
```
#### Для вложенных моделей
Используйте метод `.validator` для определения Outpost валидатора для вложенной модели.
Рассмотрим пример:
```python
# Описание модели Phone
@dataclass
class Phone:
    number: int


# Описание модели User
@dataclass
class User:
    id: int
    name: Optional[str]
    hash: Optional[str]
    # Используем ранее определенную модель Phone
    # Тип Iterable будет корректно обработан
    phones: Iterable[Phone]
    
    
# Определение валидатора для Phone с обязательным полем number
class PhoneValidator(Outpost):
    op = OutpostProvider.from_model(Phone)
    op.requirements = op.fields.number
    
# Определение валидатора для User
class UserValidator(Outpost):
    op = OutpostProvider.from_model(User)
    
    # Указание валидатора PhoneValidator для поля phones
    op.validator(op.fields.phones, PhoneValidator)
```

### !Валидация комбинаций полей (WIP)
Значения полей могут быть провалидированы совместно.\
Создайте такое правило с помощью декоратора `op.combine`. В качестве аргументов передайте поля, которые необходимо провалидировать совместно.\
Декорируемая функция должна принимать на вход количество аргументов, соответствующее количеству аргументов декоратора и поднимать ValidationError в случае ошибки.\
Каждый из аргументов получит значение соответствующего поля, прошедшего валидацию и маппинг, где применимо.\
**Комбинатор будет вызван только если во входящем наборе данных присутствуют (и валидны) значения для всех комбинируемых полей**
```python

@op.combine(op.fields.dish_list, op.fields.total_amount)
def total_combinator(dish_list:Iterable[Dish], total_amount:int):
  if sum([dish.price for dish in dish_list]) != total_amount:
    raise ValidationError("Sum of dishes prices is not equals to passed total_amount")

```

## Режимы валидации
Outpost поддерживает три режима валидации: От самого базового, до продвинутого.\
Однако каждый из них позволяет получить готовый объект модели в случае усхепа, или обработать исключение ValidationError в случае ошибки валидации данных.

### Упрощенный режим
Самый простой способ воспользоваться валидатором - вызвать статический метод `.map` у готового наследника Outpost
```python
# Пример простейщего маппинга модели из входящего набора данных
try:
  user: User = UserValidator.map(request.json)
except ValidationError as e:
  print(e)
```
Так-же у Outpost есть несколько базовых статических методов для более гибкой валидации.\
Например можно задать дополнительные значения по-умолчанию, или получить провалидированный набор данных без маппинга в модель.
```python
try:
  # Добавление значения по-умолчанию для текущей валидации набора данных для модели User
  user: User = UserValidator.update_defaults({UserValidator.fields.hash: str(uuid4())}).map(request.json)
  
  # Получение провалидированного набора даных без маппинга в модель
  user: dict = UserValidator.validated_dataset(request.json)
 
except ValidatonError as e:
  print(e)
```

### Method-chain
Любой из статических методов, вызванных у наследника Outpost приводит к созданию контекста валидации.\
Контекст валидации - это объект, содержащий в себе параметры валидации, указанные в наследнике Outpost, и обладающий всем необходимым функционалом.\
Процесс валидации происходит в несколько этапов:
- `enumerize_dataset()`: Приведение полей входящего набора данных к ModelField
  - Введение в набор данных значений по-умолчанию
  - Проверка излишних полей для случая с `.raise_unnecessary = True`
- `filter_readonly()`: Фильрация readonly полей
  - Поднятие исключения для случая с `.raise_readonly = True`
- `check_requirements()`: Проверка requirements
- `validate()`: Валидация типов
  - Вызов сложных методов валидации
  - Вызов валидаторов для вложенных моделей

Весть этот процесс валидации может быть выполнен вручную, с помощью вызова методов по цепочке.\
Началом цепочки может быть любой из методов. При этом будут выполнены все предшествующие ему.\
Результат выполнения каждого из методов может быть получен из контекста до завершения процесса валидации\
с помощью методов `.current_dataset()` или `.export_dataset()`\
`.current_dataset()` позволит получить доступ сырым данным валидации.\
Результатом будет словарь, содержащий ModelField'ы в качестве ключей и сырые промежуточные значения.\
`.export_dataset()` вернет классический словарь, похожий на исходный набор данных.
```python
try:
  # Полная цепочка валидации
  user: User = UserValidator.context().enumerize_dataset(request.json).filter_readonly().check_requirements().validate().map()
  
  # Без проверки requirements
  user: User = UserValidator.context().filter_readonly(request.json).validate().map()
  
  # Валидация без маппинга
  user: dict = UserValidator.context().validate(request.json).export_dataset()
except ValidationError as e:
  print(e)
```

### Продвинутый метод валидации
ValidationContext может быть использован в контестном меннеджере.\
Это позволит ситуативно модифицировать правила валидации для конкретного случая.\
Правила валидации содержатся в поле `.config` конекста валидации.\
**Важно помнить, что все изменения правил валидации, сделанные в контексте имеют силу только в рамках этого контекста.**\
```python
try:
  # Создание контекста валидации
  with CreateUserValidator.context() as context:
    # запрет на передачу телефонов только в случае, если создающий - НЕ администратор
    if not session.user.is_admin:
      context.config.readonly.append(context.fields.phones)
      context.config.raise_readonly = True
      
    user: User = context.map(request.json)
except ValidationError as e:
  print(e)
```
Все описанное в предыдущем разделе так-же актуально и для продвинутой валдации.


## Поддержка других правил описания моделей
Изначально Outpost был разработан для валидации dataclasses моделей с аннотациями типов из модуля typing.\
В виду того, что внутренняя логика валидации получилась весьма нетривиальной, для поддержки других правил описания моделей данных было принято решение\
использовать интерфейсы, позволяющие получить список и описание полей модели.\
Главная задача интерфейса - составить typing алиас для поля оригинальной модели.\

### Модели sqlalchemy - поддержка с версии v1.1
Описаны AlchemyFieldGenerator и AlchemyAnnotationGenerator в субмодуле .alchemy.py\
Автоматически передаются в OutpostProvider при создании через .from_model в случае, если модель создана на основе sqlalchemy.DeclarativeMeta.\
Полями модели считаются все Column и все явно указанные relationship'ы\
Аннотация типов генерируется на основе типа Column, через заранее описанные алиасы, либо на основе аргумента relationship'а\
Алиасы могут быть модифициорваны:
- Глобально:\
  `AlchemyAnnotationGenerator.appent_typealias(sqlalchemy.dialects.postgresql.json.JSON, dict)`
- Локально для контекста\
  `context.config.__annotation_generator__.__type_aliases__[sqlalchemy.dialects.postgresql.json.JSON] = dict`

Алиасы будут дополняться по мере необходимости.

При использовании sqlalchemy вероятна ситуация, когда необходимо указать валидатор для relationship'а, который еще не был создан в процессе выполнения сценария.\
В этом случае необходимо воспользоваться функционалом обещанных валидаторов.\
```python
class User(DeclarativeBase):
  __tablename__ = 'users'
  
  id = Column(Integer, primary_key=True)
  name = Column(String, nullable=False)
  # Не объявленная еще модель Phone указана как строка
  phones = relationship('Phone', back_populates="user")
  

class Phone(DeclarativeBase):
  __tablename__ = 'phones'
  id = Column(Integer, primary_key=True)
  user_id = Column(Integer, ForeignKey('users.id), nullable=False)
  user = relationship(User, back_populates='phones')
  
class PhoneValidator(Outpost):
  op = OutpostProvider.from_model(Phone)
  # Необходимо определить для поля user валидатор UserValidator, однако он еще не объявлен.
  # Используем обещанный валидатор, указав его имя через субскрипцию класса Outpost
  op.validator(op.fields.user, Outpost["UserValidator"])
  
# Общали - объявляем
class UserValidator(Oupost):
  op = OutpostProvider.from_model(User)
  # PhoneValidator уже объявлен, используем его
  op.validator(op.phones, PhoneValidator)

```
